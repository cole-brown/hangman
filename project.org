#+SEQ_TODO: todo started waiting done
#+ARCHIVE: ::* archive

--------------------------------------------------------------------------------
                                Factual Hangman
--------------------------------------------------------------------------------
                           Word Guessing Strategy 101

enough for two 82-width buffers
(set-frame-size (selected-frame) 176 76)

* Problem: Play Hangman Efficiently

The Goal

Write a program that plays the Hangman game. A description of the game can be
found [[http://en.wikipedia.org/wiki/Hangman_(game)][here]].

The Problem

Your goal is to use a provided API to play Hangman efficiently. You need to
guess a word using as few guesses as possible, and make no more than
maxWrongGuesses incorrect guesses. You are writing the letter/word guessing
strategy.

We would like you to use the provided Java APIs and to write your solution in
Java or a JVM-based language. However, if are not comfortable with that, please
feel free to use any other reasonably mainstream programming language (C++,
Python, Ruby, etc.). If you do use another language, please make sure that your
program can accept a dictionary file and a list of test words (that are in the
dictionary). The output of the program should be a score for each test word and
the average score across all test words. Also, if you don't use Java, please
provide build instructions if they are not straightforward.

Your score for a word will be:

   # letter guesses + # number of incorrect word guesses if you guessed the word
   right before exceeding maxWrongGuesses incorrect guesses

or

   25 if you lost the game before guessing the word correctly.

You will need to write an implementation of the GuessingStrategy interface and
some code to use your GuessingStrategy on a HangmanGame instance.

The pseudocode to run your strategy for a HangmanGame is:

   // runs your strategy for the given game, then returns the score
   public int run(HangmanGame game, GuessingStrategy strategy) {
     while (game has not been won or lost) {
       ask the strategy for the next guess
       apply the next guess to the game
     }
     return game.score();
   }

A trivial strategy might be to guess 'A', then 'B', then 'C', etc. until you've
guessed every letter in the word (this will work great for "cab"!) or you've
lost.

Every word you encounter will be a word from the words.txt file.

Example

For example, let's say the word is FACTUAL.

Here is what a series of calls might look like:

   HangmanGame game = new HangmanGame("factual", 4); // secret word is factual, 4 wrong guesses are allowed
   System.out.println(game);
   new GuessLetter('a').makeGuess(game);
   System.out.println(game);
   new GuessWord("natural").makeGuess(game);
   System.out.println(game);
   new GuessLetter('x').makeGuess(game);
   System.out.println(game);
   new GuessLetter('u').makeGuess(game);
   System.out.println(game);
   new GuessLetter('l').makeGuess(game);
   System.out.println(game);
   new GuessWord("factual").makeGuess(game);
   System.out.println(game);

The output would be:

   -------; score=0; status=KEEP_GUESSING
   -A---A-; score=1; status=KEEP_GUESSING
   -A---A-; score=2; status=KEEP_GUESSING
   -A---A-; score=3; status=KEEP_GUESSING
   -A--UA-; score=4; status=KEEP_GUESSING
   -A--UAL; score=5; status=KEEP_GUESSING
   FACTUAL; score=5; status=GAME_WON

game.score() will be 5 in this case since there were 4 letter guesses and 1
incorrect word guess made.

Sample Data

As a baseline, here are scores for a reasonably good guessing strategy against a
set of 15 random words. Your strategy will likely be better for some of the
words and worse for other words, but the average score/word should be in the
same ballpark.

   COMAKER = 25 (was not able to guess the word before making more than 5 mistakes)
   CUMULATE = 9
   ERUPTIVE = 5
   FACTUAL = 9
   MONADISM = 8
   MUS = 25 (was not able to guess the word before making more than 5 mistakes)
   NAGGING = 7
   OSES = 5
   REMEMBERED = 5
   SPODUMENES = 4
   STEREOISOMERS = 2
   TOXICS = 11
   TRICHROMATS = 5
   TRIOSE = 5
   UNIFORMED = 5

Resources

You should have been provided with a zip file with source code and a dictionary
file to get you started. If you were not sent this zip file, or you have any
questions about the contents, please let us know right away.

The resources contain a dictionary file called words.txt. You can assume all
words that your program will be tested with come from this dictionary file.

Judging

Your solution will be graded on the following criteria

 * code quality, readability, and design. In terms of quality, please write your
   code as if it would eventually be pushed into production.
 * performance (speed/memory footprint). We are more concerned with average time
   per game, so expensive one-time initialization is okay (as long as it's not
   too egregious)
 * total score for ~1000 random words, compared to the total score of several
   reference implementations for the same ~1000 words (max wrong guesses is
   typically set to 5)

* CMDs

none yet...

* users.txt

nada

* Costs

nada

* Notes

nada

* TODOs

*** done update python
    closed: [2012-10-03 Wed 15:17]

get 3.3.0

http://www.python.org/download/releases/3.3.0/

*** done python indent -> 3 spaces
    closed: [2012-10-04 Thu 15:05]
*** done git repo
    closed: [2012-10-04 Thu 16:49]

ignore 
  factual/
  __pycache__/
  python basic class template thing I made

*** started strategy outline

Probably a combination of popular letters & using words.txt file.

http://en.wikipedia.org/wiki/Hangman_%28game%29
  - letter freq: e-t-a-o-i-n-s-h-r-d-l-u

Once some letters, (and/or after X guesses), switch to:
  - parse word file for all possibilities
  - parse possibles for popular letters
    - reduce multiple-per-word letters to just one? 
  - try most popular (that hasn't been tried)

When to start guessing words?
  - when possible word list can all be guessed before game end?
  - when there's only one possible

* TASKS

*** done 000: Pythonification
    closed: [2012-10-03 Wed 21:41]

Convert their java to Python as first step.

*** done 001: Test HangmanGame
    closed: [2012-10-04 Thu 14:56]

Sanity test java->py.

$ python3 src/HangmanGame.py
-------; score=0; status=KEEP_GUESSING
-A---A-; score=1; status=KEEP_GUESSING
-A---A-; score=2; status=KEEP_GUESSING
-A---A-; score=3; status=KEEP_GUESSING
-A--UA-; score=4; status=KEEP_GUESSING
-A--UAL; score=5; status=KEEP_GUESSING
FACTUAL; score=5; status=GAME_WON

Output == good

*** done 002: parse word file
    closed: [2012-10-04 Thu 16:25]

File reading first. Then dump into set?
  - yes.

*** done 003: Get basic letter guessing in place
    closed: [2012-10-04 Thu 18:33]

Pick next letter based on what's already been guessed.

Uh... I need a game runner first...
  done.

And... this is working.
  -------; score=1; status=KEEP_GUESSING
  ---T---; score=2; status=KEEP_GUESSING
  -A-T-A-; score=3; status=KEEP_GUESSING
  -A-T-A-; score=4; status=KEEP_GUESSING
  -A-T-A-; score=5; status=KEEP_GUESSING
  -A-T-A-; score=6; status=KEEP_GUESSING
  -A-T-A-; score=7; status=KEEP_GUESSING
  -A-T-A-; score=25; status=GAME_LOST
  FACTUAL = 25

*** done 004: game running script
    closed: [2012-10-04 Thu 17:42]

Make it so!

run function like so:
  public int run(HangmanGame game, GuessingStrategy strategy)

*** done 005: move DBG() to separate file
    closed: [2012-10-05 Fri 15:16]

Make it DBG(printable, prefix="", printFlag=True)

*** done 006: word finding
    closed: [2012-10-04 Thu 21:03]

Use guessedSoFar to figure out word candidates.

Probably should regex it.

Pretty stupid regex builder, but it works. We'll see if we need speed later.

*** done 007: smarter letter guesser
    closed: [2012-10-04 Thu 21:06]

build letter frequency info from possible word list

use it instead of common english letters

Hey. I didn't lose this time!

  $ ./hangman.py
  1.7 MiB
  Possibles: 23208
  RUBEOLA
  GUESS: E
  -------; score=1; status=KEEP_GUESSING
  Possibles: 23208
  RUBEOLA
  GUESS: S
  -------; score=2; status=KEEP_GUESSING
  Possibles: 23208
  RUBEOLA
  GUESS: I
  -------; score=3; status=KEEP_GUESSING
  Possibles: 23208
  RUBEOLA
  GUESS: A
  -A---A-; score=4; status=KEEP_GUESSING
  Possibles: 300
  LASHKAR
  GUESS: L
  -A---AL; score=5; status=KEEP_GUESSING
  Possibles: 46
  LACUNAL
  GUESS: T
  -A-T-AL; score=6; status=KEEP_GUESSING
  Possibles: 7
  LACTEAL
  GUESS: C
  -ACT-AL; score=7; status=KEEP_GUESSING
  Possibles: 3
  LACTEAL
  GUESS: U
  -ACTUAL; score=8; status=KEEP_GUESSING
  Possibles: 2
  TACTUAL
  GUESS: F
  FACTUAL; score=9; status=GAME_WON
  FACTUAL = 9

*** done 008: smarter word finding
    closed: [2012-10-04 Thu 21:34]

Reject words containing failed guesses

getIncorrectlyGuessedLetters()
regex set...
  [badletters]+

Any matches, throw out.

Rejecting based on incorrect letters
  - may need to update for incorrect words when word guessing goes in
    - been TODO'd in code

*** done 009: BUG: wrong letter regex
    closed: [2012-10-05 Fri 15:39]

regex to remove words containing incorrect letter choice bugged
  - but working partially... it removes some.

  $ ./hangman.py 
  1.7 MiB
  Possibles: 23208
  Pick: BOOZIERset()
  GUESS: E
  -------; score=1; status=KEEP_GUESSING
  [E]+
  Possibles: 22401
  Pick: BOOZIER{'E'}
  GUESS: S
  -------; score=2; status=KEEP_GUESSING
  [ES]+
  Possibles: 19745
  Pick: BOOZIER{'E', 'S'}
  GUESS: I
  -------; score=3; status=KEEP_GUESSING
  [EIS]+
  Possibles: 19241
  Pick: BOOZIER{'E', 'I', 'S'}
  GUESS: A
  -A---A-; score=4; status=KEEP_GUESSING
  [EIS]+
  Possibles: 279
  Pick: VATICAL{'E', 'I', 'S'}
  GUESS: L
  -A---AL; score=5; status=KEEP_GUESSING
  [EIS]+
  Possibles: 45
  Pick: VATICAL{'E', 'I', 'S'}
  GUESS: T
  -A-T-AL; score=6; status=KEEP_GUESSING
  [EIS]+
  Possibles: 7
  Pick: CANTHAL{'E', 'I', 'S'}
  GUESS: C
  -ACT-AL; score=7; status=KEEP_GUESSING
  [EIS]+
  Possibles: 3
  Pick: LACTEAL{'E', 'I', 'S'}
  GUESS: U
  -ACTUAL; score=8; status=KEEP_GUESSING
  [EIS]+
  Possibles: 2
  Pick: TACTUAL{'E', 'I', 'S'}
  GUESS: F
  FACTUAL; score=9; status=GAME_WON
  FACTUAL = 9

Ah, match(). Don't use match. Use search().

*** done 010: word guessing
    closed: [2012-10-05 Fri 16:51]

Currently only guesses at words if it's possible to win that way.

*** done 011: command line optinos
    closed: [2012-10-05 Fri 18:00]

 - location of dictionary
 - list of words
 - max guesses

$ ./hangman.py -h
usage: hangman.py [-h] [-g GUESSES] filename word [word ...]

positional arguments:
  filename              read dictionary in from file
  word                  list of words to play hangman on

optional arguments:
  -h, --help            show this help message and exit
  -g GUESSES, --guesses GUESSES
                        max number of wrong guesses

*** done 012: Modify to work for multiple games
    closed: [2012-10-05 Fri 18:47]

Reuse strategy.

Also:
- average score

*** done 013: test on words
    closed: [2012-10-05 Fri 18:55]

Their words:
   COMAKER = 25 (was not able to guess the word before making more than 5 mistakes)
   CUMULATE = 9
   ERUPTIVE = 5
   FACTUAL = 9
   MONADISM = 8
   MUS = 25 (was not able to guess the word before making more than 5 mistakes)
   NAGGING = 7
   OSES = 5
   REMEMBERED = 5
   SPODUMENES = 4
   STEREOISOMERS = 2
   TOXICS = 11
   TRICHROMATS = 5
   TRIOSE = 5
   UNIFORMED = 5
   average: 8.666666666

$ ./hangman.py words.txt COMAKER CUMULATE ERUPTIVE FACTUAL MONADISM MUS NAGGING OSES REMEMBERED SPODUMENES STEREOISOMERS TOXICS TRICHROMATS TRIOSE UNIFORMED
   COMAKER = 12
   CUMULATE = 9
   ERUPTIVE = 8
   FACTUAL = 10
   MONADISM = 6
   MUS = 25
   NAGGING = 5
   OSES = 4
   REMEMBERED = 5
   SPODUMENES = 4
   STEREOISOMERS = 3
   TOXICS = 7
   TRICHROMATS = 5
   TRIOSE = 7
   UNIFORMED = 10
   average: 7.999999999999999

Yay. 0.77777777777 better!

*** done 014: timing
    closed: [2012-10-06 Sat 20:47]

Seems a bit slow. 

15 words:
  real	0m6.904s
  user	0m6.815s
  sys	0m0.086s

1000 would take... half an hour-ish.

Get timing on function level...
  util.Timer is ready for action!

Now start using it.

  $ time ./hangman.py words.txt MUS
  Namespace(filename='words.txt', guesses=5, verbose=False, word=['MUS'])
  Strategy init took 0.191967964 sec.
  Strategery took 0.197170019 sec.
  Strategery took 0.010432959 sec.
  Strategery took 0.008641958 sec.
  Strategery took 0.007431984 sec.
  Strategery took 0.006187916 sec.
  Strategery took 0.006028175 sec.
  Strategery took 0.005857944 sec.
  Game took 0.242306948 sec.
  MUS = 25
  average: 25.0
  Total: 0.260428905 sec.

So, the first guess takes way too long... 75% of the run is the first guess.

But the timing works, so #014 is done.

*** 015: Faster strategy

Speed up first strategy run.
  - don't do regexes, since they're useless. We haven't guessed anything yet.
  - just check word lengths

Slightly better.

previous:
  Strategery took 0.197170019 sec.
now:
  Strategery took 0.163403034 sec.

The possible words update takes pretty much all the strategy time.
  Update     took 0.155512094 sec.
  Strategery took 0.164095163 sec.

  Update     took 0.004542828 sec.
  Strategery took 0.010727882 sec.

  Update     took 0.003679991 sec.
  Strategery took 0.008900166 sec.

  Update     took 0.003553867 sec.
  Strategery took 0.007694006 sec.

  Update     took 0.003237009 sec.
  Strategery took 0.006378174 sec.

  Update     took 0.002988100 sec.
  Strategery took 0.006038904 sec.

  Update     took 0.002842903 sec.
  Strategery took 0.005592108 sec.

Iterations over the set isn't the problem.
  ITERATION took 0.014471054 sec.
But still, don't really want to do that every time... do you?

Maybe:
  Divide words up into different sets based on length.
  Possible words tree, basically.

foo = defaultdict(set)
foo[secretWordLen] <-- just the possible words of that length

Also Maybe:
  map() stuff

*** 999:

* example

None.



# Local Variables: 
# fill-column:80
# End: 
